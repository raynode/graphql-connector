import { AnyModel, createModelMapper, GeneratedModelMapper, Page } from '@raynode/graphql-connector'
import { capitalize } from 'inflection'
import * as Sequelize from 'sequelize'
import { DataTypes } from './type-guards'
import { applyParser, createEmptyFilter, ParsedFilter, parser } from './filter-parser'

// somehow the sequelize types are really really bad!
export interface SequelizeAttributeReference {
  model: string
  key: string
}

export interface SequelizeAttribute extends Sequelize.DefineAttributeColumnOptions {
  // should this attribute be represented in the SDL and be handled by graphql-connector (default: true)
  visible?: boolean
  // should this attribute be in the update mutation (default: true)
  updateable?: boolean
  // should this attribute be in the create mutation (default: true)
  createable?: boolean
  // these are correct, but incompatible... these sequelize types...
  type: DataTypes | Sequelize.DataTypeAbstract
}

export type SequelizeAttributes<Keys extends string = string> = Record<Keys, string |Â SequelizeAttribute>

export type SequelizeAssociationTypes = 'HasOne' | 'HasMany' | 'BelongsTo' | 'BelongsToMany'

export interface SequelizeAssociation {
  source: SequelizeModel
  target: SequelizeModel
  as: string
  associationType: SequelizeAssociationTypes
  foreignKeyAttribute: string
  foreignKey: string
  identifier: string
  targetKey: string
  targetKeyField: string
  targetKeyIsPrimary: string
  targetIdentifier: string
  accessors: Record<string, string>
  identifierField: string
}

export interface SequelizeModel extends Sequelize.Model<any, any> {
  rawAttributes: Record<string, SequelizeAttribute>
  associations: Record<string, SequelizeAssociation>
}

export interface Models {
  [x: string]: Sequelize.Model<any, any>
}

const createPage = (offset: number, limit: number, page: number): Page => ({
  offset, limit, page,
})

export const isListAssociation = (association: SequelizeAssociation) =>
  association.associationType === 'HasMany' || association.associationType === 'BelongsToMany'

export const modelMapper = createModelMapper<DataTypes, Models>((model, addAttribute, addAssociation) => {
  const rawModel: SequelizeModel = model as any
  Object.keys(rawModel.rawAttributes).forEach(name => {
    const attribute = rawModel.rawAttributes[name]
    if(attribute.visible === false)
      return

    addAttribute({
      name,
      type: attribute.type as DataTypes,
      nonNull: attribute.allowNull === false || attribute.primaryKey === true,
      resolver: instance => instance[name],
      // changable: !(attribute._autoGenerated || attribute.primaryKey || attribute.references),
    })
  })

  Object.keys(rawModel.associations).forEach(name => {
    const association = rawModel.associations[name]
    const list = isListAssociation(association)
    addAssociation({
      name: association.as,
      model: association.target.name,
      list,
      nonNull: association.associationType === 'BelongsTo' || association.associationType === 'BelongsToMany',
      resolver: async (instance, args, context, info) => {
        // @TODO
        // this needs to correctly submit nodes and page when done!
        const getter = `${capitalize(association.as)}`
        const res = await instance[`get${getter}`]()

        return list
        ? {
          nodes: res,
          page: createPage(0, 100, 0),
        } : res
      },
    })
  })

  const findAll = async (include, where, order?) => {
    const nodes = await model.findAll({ include, where, order })
    return {
      nodes,
      page: createPage(0, 100, 0),
    }
  }

  const findFromModel = (model: SequelizeModel, list: boolean, filter: ParsedFilter) => list
  ? model.findAll(filter)
  : model.findOne(filter)

  const getModelData = (association: SequelizeAssociation, data: any) =>
    findFromModel(association.target, isListAssociation(association), applyParser(association.target, data))

  const reduceUpdateData = async (data: any) => {
    await Promise.all(Object.keys(rawModel.associations).map(async name => {
      const association = rawModel.associations[name]
      if(!data.hasOwnProperty(name))
        return
      const modelData = await getModelData(association, data[name])
      delete data[name]
      data[association.identifierField] = modelData[association.targetIdentifier]
    }))
    return data
  }

  const resolvers = {
    create: async (_, { data }) => model.create(await reduceUpdateData(data)),
    delete: async (_, { where: { where } }) => {
      const deletedItems = await model.findAll({ where })
      await model.destroy({ where })
      return deletedItems
    },
    findMany: async (_, { order, where: { where = {}, include = [] } = {} }) => findAll(include, where, order),
    findOne: async (_, { order, where: { where = {}, include = [] } = {} }) => model.findOne({ include, where, order }),
    update: async (_, { data, where: { where, include } }) => {
      await model.update(data, { where })
      const results = await model.findAll({ where })

      await Promise.all(Object.keys(rawModel.associations).map(async name => {
        const association = rawModel.associations[name]
        if(!data.hasOwnProperty(name))
          return
        const modelData = await getModelData(association, data[name])
        return Promise.all(results.map(result => result[association.accessors.set](modelData)))
      }))
      return results
    },
  }
  return resolvers
})
